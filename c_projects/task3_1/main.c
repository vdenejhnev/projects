#include <stdio.h>
#include <stdlib.h>

struct node {
    int data;
    struct node* left, *right;
};
//1
int create(char*, int);  // создает бинарный файл из последовательностей чисел
//2, 4
char* createName(char*);  // создает имя текстового файла
void createT(char*, char*);  // переделывает бинарный файл в текстовый
//3
void sort_file(char*);  // сортирует бинарный файл и выводит результат на экран
FILE* sort_sequence(FILE* fp);  // сортировка одной последовательности в файле
FILE* print(FILE*, struct node *);  // печать дерева в файл и на экран
struct node* add(struct node*, int);  // добавление элемента в дерево
void clear(struct node*);  // освобождение памяти

int main(int argc, char** argv) {
    if (argc > 1) {  // проверка на содержание имени файла в командной строке
        int N;
        char* name, * nameT;
        name = argv[1];
        nameT = createName(name);  // создание имен для бинарного и текстовых файлов

        if (scanf("%d", &N) == 1 && N >= 0 && create(name, N)) {  // проверка количества последовательностей на корректность и создание бинарного файла
            createT(name, nameT);  // создание текстового файла
            sort_file(name);  // сортировка бинарного файла и вывод отсортированных последовательностей на экран
            createT(name, nameT);  // создание текстового файла из отсортированных последовательностей
        } else {
            fprintf(stderr, "Incorrect input data\n");  // вывод ошибки в случае если число последовательнотей введено неверно
        }
        free(nameT);  // очищение памяти для имени текстового файла
    } else {
        fprintf(stderr, "file name not specified\n");  // вывод ошибки в случае, если имя файла не указано
    }
}

int create(char* name, int N) {  // создание бинарного файла. Возвращает 1, если запись прошла успешно, 0 - иначе
    FILE* fp = fopen(name, "w");  // создаем и открываем бинарный файл на запись
    int i;
    for (i = 0; i < N; ++i) {  // счетчик для последовательностей
        int k, p;

        while ((p = scanf("%d", &k)) == 1 && k)  // проверка на корректность вводимых данных и проверка на конец файла
            fwrite(&k, sizeof(int), 1, fp);  // запись числа в бинарный файл

        if (p != 1 && i != N - 1) { // проверяем почему произошел вызод из цикла, если p != 1, то выход произошел потому что был достигнут конец файла, а ввод еще требуется, либо было введено не число
            fclose(fp);
            fp = fopen(name, "w");  // очищаем файл от добавленных данных, так как произошел некорректно
            return 0;
        } else {
            if (i != N - 1 || !k)
                fwrite(&k, sizeof(int), 1, fp);  // если считывание произошло корректно, то добавляем 0 в бинарный файл и переходим к следующей последовательности
        }
    }
    fclose(fp);  // закрываем файл
    return 1;
}

char* createName(char* name) {  // создание имени для текстового файла
    char* s = name, *nameT;
    int n = 0;  // счетчик символов в имени файла
    while (*s) {
        n++;
        s++;
    }
    n += 2;  // изменяем для нового имени с учетом добавляемого символа 'T' и '\0'
    nameT = malloc(sizeof(char) * n);  // выделение памяти для новой строки
    s = nameT;
    while (*name) {  // копирование имени бинарного файла в имя текстового
        *nameT = *name;
        nameT++;
        name++;
    }
    *nameT = 'T';  // добавление символа 'T' в имя текстового файла
    nameT++;
    *nameT = '\0';  // и указываем конец строки
    return s;
}

void createT(char* name, char* nameT) {  // формирование текстового файла из бинарного
    FILE* fp = fopen(name, "r");  // открываем бинарный файл на чтение
    if (fp) {  // проверка на существование файла
        FILE* fpT = fopen(nameT, "w");  // создаем и открываем текстовый файл на запись
        int k;

        while (fread(&k, sizeof(int), 1, fp)) {  // пока есть что считать из бинарного файла будем проверять
            if (k)  // если k не 0
                fprintf(fpT, "%d ", k);  // записываем k в текстовый файл
            else
                fprintf(fpT, "%d\n", k); // иначе записываем 0 и ставим перенос строки
        }
        fclose(fp);
        fclose(fpT);
    } else {
        fprintf(stderr, "no file \'%s\'\n", name);
    }
}

void sort_file(char * name) {  // сортировка последовательностей в бинарном файле
    FILE *fp = fopen(name, "r+");  // открываем бинарный файл на чтение
    if (fp) {  // проверка на существование файла
        long p;
        fseek(fp, 0, SEEK_END);
        p = ftell(fp);
        fseek(fp, 0, SEEK_SET);
        while (p - 1 > ftell(fp))
            fp = sort_sequence(fp);  // сортируем каждую последовательность, функция вернет файловый указатель на следующую последовательность
        fclose(fp);  // закрываем бинарный файл
    } else {
        fprintf(stderr, "no file \'%s\'\n", name);
    }
}

FILE* sort_sequence(FILE* fp) {  // сортировка одной последовательности бинарного файла и возврат указателя на след последовательность
    struct node* tree = NULL;  // создаем пустое дерево
    int n = 1, k;  // n - количество чисел в последовательности, k - читаемый символ из бинарного файла

    while (fread(&k, sizeof(int), 1, fp) && k) {  // пока идет чтение из файла и k не равно нулю (не достигнут конец последовательности)
        tree = add(tree, k);  // добавляем в дерево число k
        n++;  // увеличиваем количество чисел в последовательности, чтобы потом сместиться на начало последовательноти для ее перезаписи в отсортированном виде
    }

    if (feof(fp))  // проверка на последнюю последовательность, если она не содержит 0 на конце
        n -= 1;  // то нужно сдвинуться на n - 1

    fseek(fp, -sizeof(int) * n, SEEK_CUR);  // смещаемся на начало последовательности
    fp = print(fp, tree);  // записываем туда дерево, вернется указатель конец последовательности (на 0)
    printf("\n");
    fseek(fp, sizeof(int), SEEK_CUR); // смещаемся еще на один элемент чтобы fp указывал на следующую последовательность
    clear(tree);  // освобождаем память для созданного дерева
    return fp;
}

FILE* print(FILE* fp, struct node *tree) {  // печать дерева в файл и на экран. Функция возвращает указатель на конец последовательности (на 0)
    if (tree) {  // если дерево сущестует
        if (tree->left)  // печатаем сначала левое поддерево
            fp = print(fp, tree->left);
        printf("%d ", tree->data);  // элемент на который указывает дерево
        fwrite(&(tree->data), sizeof(int), 1, fp);
        if (tree->right)  // печатаем правое поддерево
            fp = print(fp, tree->right);
    }
    return fp;
}

struct node* add(struct node* tree, int k) {  // добавление элемента в дерево, возвращает указатель на измененное дерево
    if (tree) {  // если дерево не пусто
        if (k >= tree->data)
            tree->right = add(tree->right, k);  // переходим в правое поддерево, если k больше ключа
        else
            tree->left = add(tree->left, k);  // переходим в левое поддерево, если k больше ключа
    } else {
        tree = malloc(sizeof(struct node));  // в случае пустого дерева создаем его
        tree->data = k;
        tree->left = NULL;
        tree->right = NULL;
    }
    return tree;
}

void clear(struct node* tree) {  // освобождение памяти
    if (tree) {
        clear(tree->left);  // освобождение левого поддерева
        clear(tree->right);  // освобождение правого поддерева
        free(tree);  // освобождение листа
    }
}
